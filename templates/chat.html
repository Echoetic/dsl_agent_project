<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ scenario_info.name }} - DSLæ™ºèƒ½Agent</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300;400;500;700&display=swap" rel="stylesheet">
</head>
<body class="chat-page">
    <div class="chat-container">
        <header class="chat-header">
            <a href="/" class="back-btn">â† è¿”å›</a>
            <div class="header-info">
                <span class="header-icon">{{ scenario_info.icon }}</span>
                <div>
                    <h1>{{ scenario_info.name }}</h1>
                    <p>{{ scenario_info.description }}</p>
                </div>
            </div>
            <button id="restartBtn" class="restart-btn" title="é‡æ–°å¼€å§‹">ğŸ”„</button>
        </header>

        <main class="chat-main">
            <div class="chat-messages" id="chatMessages">
                <div class="message system">
                    <div class="message-content">
                        <p>æ­£åœ¨è¿æ¥æ™ºèƒ½å®¢æœ...</p>
                    </div>
                </div>
            </div>

            <div class="quick-replies" id="quickReplies"></div>
        </main>

        <footer class="chat-input-area">
            <div class="input-wrapper">
                <input type="text" id="userInput" placeholder="è¯·è¾“å…¥æ‚¨çš„é—®é¢˜..." autocomplete="off">
                <button id="sendBtn" class="send-btn">
                    <span>å‘é€</span>
                </button>
            </div>
            <div class="input-tips">
                <span id="statusIndicator" class="status-dot"></span>
                <span id="statusText">è¿æ¥ä¸­...</span>
            </div>
        </footer>
    </div>

    <script>
        const scenario = '{{ scenario }}';
        let sessionId = null;
        let isWaitingForResponse = false;

        const chatMessages = document.getElementById('chatMessages');
        const userInput = document.getElementById('userInput');
        const sendBtn = document.getElementById('sendBtn');
        const restartBtn = document.getElementById('restartBtn');
        const quickReplies = document.getElementById('quickReplies');
        const statusIndicator = document.getElementById('statusIndicator');
        const statusText = document.getElementById('statusText');

        // æ·»åŠ æ¶ˆæ¯åˆ°èŠå¤©çª—å£
        function addMessage(content, type = 'bot') {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            
            // å¤„ç†å¤šè¡Œæ¶ˆæ¯
            const lines = content.split('\n').filter(line => line.trim());
            lines.forEach((line, index) => {
                const p = document.createElement('p');
                p.textContent = line;
                contentDiv.appendChild(p);
            });
            
            const timeSpan = document.createElement('span');
            timeSpan.className = 'message-time';
            timeSpan.textContent = new Date().toLocaleTimeString('zh-CN', {hour: '2-digit', minute: '2-digit'});
            contentDiv.appendChild(timeSpan);
            
            messageDiv.appendChild(contentDiv);
            chatMessages.appendChild(messageDiv);
            
            // æ»šåŠ¨åˆ°åº•éƒ¨
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // æ˜¾ç¤ºå¿«æ·å›å¤æŒ‰é’®
        function showQuickReplies(intents) {
            quickReplies.innerHTML = '';
            if (intents && intents.length > 0) {
                // åªæ˜¾ç¤ºå‰6ä¸ªæ„å›¾
                const displayIntents = intents.slice(0, 6);
                displayIntents.forEach(intent => {
                    const btn = document.createElement('button');
                    btn.className = 'quick-reply-btn';
                    btn.textContent = intent;
                    btn.onclick = () => sendMessage(intent);
                    quickReplies.appendChild(btn);
                });
            }
        }

        // æ›´æ–°çŠ¶æ€
        function updateStatus(status, text) {
            statusIndicator.className = `status-dot ${status}`;
            statusText.textContent = text;
        }

        // å‘é€æ¶ˆæ¯
        async function sendMessage(message = null) {
            const text = message || userInput.value.trim();
            if (!text || isWaitingForResponse) return;
            
            // æ˜¾ç¤ºç”¨æˆ·æ¶ˆæ¯
            addMessage(text, 'user');
            userInput.value = '';
            quickReplies.innerHTML = '';
            
            // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
            isWaitingForResponse = true;
            updateStatus('loading', 'æ­£åœ¨å¤„ç†...');
            sendBtn.disabled = true;
            
            try {
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        scenario: scenario,
                        session_id: sessionId,
                        message: text
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    if (data.message) {
                        addMessage(data.message, 'bot');
                    }
                    
                    // æ˜¾ç¤ºå¿«æ·å›å¤
                    if (data.available_intents) {
                        showQuickReplies(data.available_intents);
                    }
                    
                    // æ›´æ–°çŠ¶æ€
                    if (data.state === 'FINISHED') {
                        updateStatus('offline', 'å¯¹è¯å·²ç»“æŸ');
                        userInput.disabled = true;
                        sendBtn.disabled = true;
                    } else if (data.waiting_for_input) {
                        updateStatus('online', 'ç­‰å¾…æ‚¨çš„å›å¤');
                    } else {
                        updateStatus('online', 'åœ¨çº¿');
                    }
                    
                    // æ£€æŸ¥ä¼šè¯æ˜¯å¦é‡å¯
                    if (data.session_restarted) {
                        addMessage('ä¼šè¯å·²é‡æ–°å¼€å§‹', 'system');
                    }
                } else {
                    addMessage('æŠ±æ­‰ï¼Œå¤„ç†æ‚¨çš„è¯·æ±‚æ—¶å‡ºç°é”™è¯¯ï¼š' + data.error, 'system');
                    updateStatus('error', 'å‘ç”Ÿé”™è¯¯');
                }
            } catch (error) {
                console.error('Error:', error);
                addMessage('ç½‘ç»œè¿æ¥å‡ºç°é—®é¢˜ï¼Œè¯·ç¨åé‡è¯•ã€‚', 'system');
                updateStatus('error', 'è¿æ¥å¤±è´¥');
            } finally {
                isWaitingForResponse = false;
                sendBtn.disabled = false;
            }
        }

        // å¯åŠ¨ä¼šè¯
        async function startSession() {
            updateStatus('loading', 'è¿æ¥ä¸­...');
            chatMessages.innerHTML = '';
            addMessage('æ­£åœ¨è¿æ¥æ™ºèƒ½å®¢æœ...', 'system');
            
            try {
                const response = await fetch('/api/start', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        scenario: scenario
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    sessionId = data.session_id;
                    
                    // æ¸…é™¤åˆå§‹æ¶ˆæ¯
                    chatMessages.innerHTML = '';
                    
                    // æ˜¾ç¤ºæ¬¢è¿æ¶ˆæ¯
                    if (data.message) {
                        addMessage(data.message, 'bot');
                    }
                    
                    // æ˜¾ç¤ºå¿«æ·å›å¤
                    if (data.available_intents) {
                        showQuickReplies(data.available_intents);
                    }
                    
                    updateStatus('online', 'åœ¨çº¿');
                    userInput.disabled = false;
                    sendBtn.disabled = false;
                    userInput.focus();
                } else {
                    addMessage('è¿æ¥å¤±è´¥ï¼š' + data.error, 'system');
                    updateStatus('error', 'è¿æ¥å¤±è´¥');
                }
            } catch (error) {
                console.error('Error:', error);
                addMessage('æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•ã€‚', 'system');
                updateStatus('error', 'è¿æ¥å¤±è´¥');
            }
        }

        // é‡æ–°å¼€å§‹ä¼šè¯
        async function restartSession() {
            if (sessionId) {
                try {
                    await fetch('/api/end', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            scenario: scenario,
                            session_id: sessionId
                        })
                    });
                } catch (error) {
                    console.error('Error ending session:', error);
                }
            }
            
            userInput.disabled = false;
            sendBtn.disabled = false;
            quickReplies.innerHTML = '';
            startSession();
        }

        // äº‹ä»¶ç›‘å¬
        sendBtn.addEventListener('click', () => sendMessage());
        
        userInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });
        
        restartBtn.addEventListener('click', restartSession);

        // é¡µé¢åŠ è½½æ—¶å¯åŠ¨ä¼šè¯
        document.addEventListener('DOMContentLoaded', startSession);
        
        // é¡µé¢å…³é—­æ—¶ç»“æŸä¼šè¯
        window.addEventListener('beforeunload', () => {
            if (sessionId) {
                navigator.sendBeacon('/api/end', JSON.stringify({
                    scenario: scenario,
                    session_id: sessionId
                }));
            }
        });
    </script>
</body>
</html>
